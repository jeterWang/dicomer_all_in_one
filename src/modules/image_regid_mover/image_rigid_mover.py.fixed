#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import glob
import logging
import SimpleITK as sitk
import numpy as np
from typing import Tuple, List, Dict, Optional, Union
from PyQt5.QtCore import QObject, pyqtSignal
import pydicom
from pydicom.dataset import FileDataset, FileMetaDataset
from datetime import datetime

# 忽略pydicom的弃用警告
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", message=".*FileDataset.is_little_endian.*")
warnings.filterwarnings("ignore", message=".*FileDataset.is_implicit_VR.*")
warnings.filterwarnings("ignore", message=".*write_like_original.*")

class ImageRigidMover(QObject):
    """
    实现医学图像的刚体位移配准
    支持DICOM图像和结构集(RTSS)的同步变换
    """
    
    # 定义信号用于进度更新
    progress_updated = pyqtSignal(int, str)  # (进度百分比, 状态消息)
    process_finished = pyqtSignal(bool, str)  # (是否成功, 消息)
    image_loaded = pyqtSignal(dict)  # 图像加载完成信号，携带图像信息
    
    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        
        # 存储加载的图像和结构集
        self.fixed_data = {
            'images': [],           # 存储固定图像
            'rtss': None,           # 存储固定图像的结构集
            'image_files': [],      # 图像文件路径列表
            'rtss_file': None,      # 结构集文件路径
            'image_info': {},       # 图像元信息
            'loaded': False         # 是否已加载
        }
        
        self.moving_data = {
            'images': [],           # 存储移动图像
            'rtss': None,           # 存储移动图像的结构集
            'image_files': [],      # 图像文件路径列表
            'rtss_file': None,      # 结构集文件路径
            'image_info': {},       # 图像元信息
            'loaded': False         # 是否已加载
        }
        
        # 变换参数
        self.transform_params = {
            'tx': 0.0,  # x方向平移（mm）
            'ty': 0.0,  # y方向平移（mm）
            'tz': 0.0,  # z方向平移（mm）
            'rx': 0.0,  # x轴旋转（度）
            'ry': 0.0,  # y轴旋转（度）
            'rz': 0.0,  # z轴旋转（度）
        }
        
        # 输出目录
        self.output_dir = None
    
    def load_directory(self, directory: str, is_fixed: bool = True) -> Tuple[bool, str, Dict]:
        """
        加载目录中的DICOM图像和结构集
        
        Args:
            directory: 包含DICOM序列的目录
            is_fixed: 是否作为固定图像加载，否则作为移动图像
            
        Returns:
            Tuple[bool, str, Dict]: (成功标志, 消息, 数据字典)
        """
        try:
            self.logger.info(f"正在加载目录: {directory}, 作为{'固定' if is_fixed else '移动'}图像")
            self.progress_updated.emit(0, f"开始加载{'固定' if is_fixed else '移动'}图像...")
            
            # 确定是加载到fixed还是moving
            data_dict = self.fixed_data if is_fixed else self.moving_data
            
            # 重置数据
            data_dict['images'] = []
            data_dict['rtss'] = None
            data_dict['image_files'] = []
            data_dict['rtss_file'] = None
            data_dict['image_info'] = {}
            data_dict['loaded'] = False
            
            # 检查目录是否存在
            if not os.path.exists(directory):
                return False, f"目录不存在: {directory}", data_dict
                
            # 尝试首先通过GDCM识别序列，这对变换后的序列特别有效
            try:
                self.logger.info("尝试使用GDCM识别DICOM序列...")
                self.progress_updated.emit(20, "识别DICOM序列...")
                
                # 获取目录中的所有序列UID
                series_ids = sitk.ImageSeriesReader.GetGDCMSeriesIDs(directory)
                
                if series_ids:
                    self.logger.info(f"发现 {len(series_ids)} 个DICOM序列")
                    
                    # 使用第一个找到的序列
                    series_id = series_ids[0]
                    image_files = sitk.ImageSeriesReader.GetGDCMSeriesFileNames(directory, series_id)
                    
                    if image_files:
                        self.logger.info(f"使用序列 {series_id}, 包含 {len(image_files)} 个文件")
                        data_dict['image_files'] = image_files
                        
                        # 检查RTSS文件
                        dicom_candidates = [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]
                        for file_name in dicom_candidates:
                            file_path = os.path.join(directory, file_name)
                            try:
                                dcm = pydicom.dcmread(file_path, force=True, stop_before_pixels=True)
                                if hasattr(dcm, 'SOPClassUID') and dcm.SOPClassUID == '1.2.840.10008.5.1.4.1.1.481.3':
                                    data_dict['rtss_file'] = file_path
                                    self.logger.info(f"找到RTSS文件: {file_path}")
                                    break
                            except Exception:
                                pass
                else:
                    # 如果没有找到序列，使用标准的文件搜索方法
                    self.logger.info("未通过GDCM找到序列，尝试标准文件搜索...")
                    
                    # 列出所有文件
                    dicom_candidates = [os.path.join(directory, f) for f in os.listdir(directory) 
                                      if os.path.isfile(os.path.join(directory, f))]
                    
                    # 对找到的文件进行分类
                    image_files = []
                    rtss_file = None
                    
                    for file_path in dicom_candidates:
                    try:
                            dcm = pydicom.dcmread(file_path, force=True, stop_before_pixels=True)
                            
                            # 检查是否为RTSS
                            if hasattr(dcm, 'SOPClassUID') and dcm.SOPClassUID == '1.2.840.10008.5.1.4.1.1.481.3':
                                rtss_file = file_path
                                self.logger.info(f"找到RTSS文件: {file_path}")
                            # 检查是否为医学图像(CT/MR/PT)
                            elif hasattr(dcm, 'Modality') and dcm.Modality in ['CT', 'MR', 'PT']:
                                image_files.append(file_path)
                        except Exception:
                        # 可能不是DICOM文件，忽略
                        continue
                    
                    data_dict['image_files'] = image_files
                    data_dict['rtss_file'] = rtss_file
                    
                    # 如果没有找到文件，使用glob搜索
                    if not image_files:
                        self.logger.info("尝试使用glob搜索DICOM文件...")
                        for ext in ['.dcm', '.DCM', '']:
                            pattern = os.path.join(directory, f"*{ext}")
                            candidates = glob.glob(pattern)
                            for file_path in candidates:
                                if os.path.isfile(file_path):
                                    try:
                                        dcm = pydicom.dcmread(file_path, force=True, stop_before_pixels=True)
                                        if hasattr(dcm, 'Modality') and dcm.Modality in ['CT', 'MR', 'PT']:
                                            image_files.append(file_path)
                                    except Exception:
                                        continue
                        
                        data_dict['image_files'] = image_files
            
            except Exception as e:
                self.logger.warning(f"GDCM序列识别失败: {e}，尝试标准文件搜索...")
                
                # 列出所有文件
                dicom_candidates = [os.path.join(directory, f) for f in os.listdir(directory) 
                                  if os.path.isfile(os.path.join(directory, f))]
            
            # 对找到的文件进行分类
            image_files = []
            rtss_file = None
            
                for file_path in dicom_candidates:
                    try:
                    dcm = pydicom.dcmread(file_path, force=True, stop_before_pixels=True)
                    
                    # 检查是否为RTSS
                    if hasattr(dcm, 'SOPClassUID') and dcm.SOPClassUID == '1.2.840.10008.5.1.4.1.1.481.3':
                        rtss_file = file_path
                        self.logger.info(f"找到RTSS文件: {file_path}")
                    # 检查是否为医学图像(CT/MR/PT)
                    elif hasattr(dcm, 'Modality') and dcm.Modality in ['CT', 'MR', 'PT']:
                        image_files.append(file_path)
                    except Exception:
                        # 可能不是DICOM文件，忽略
                        continue
            
            data_dict['image_files'] = image_files
            data_dict['rtss_file'] = rtss_file
            
            # 检查是否找到图像文件
            image_files = data_dict['image_files']
            if not image_files:
                return False, f"目录 {directory} 中未找到有效的DICOM图像文件", data_dict
                
            self.logger.info(f"找到 {len(image_files)} 个DICOM图像文件")
            self.progress_updated.emit(40, f"找到 {len(image_files)} 个DICOM图像文件")
                
            # 尝试加载图像序列
            try:
                self.progress_updated.emit(60, "加载DICOM图像序列...")
                
                # 使用SimpleITK的序列读取器
                reader = sitk.ImageSeriesReader()
                    reader.SetFileNames(image_files)
                    image = reader.Execute()
                    
                data_dict['images'] = [image]
                
                # 提取图像信息
                data_dict['image_info'] = {
                        'size': image.GetSize(),
                        'spacing': image.GetSpacing(),
                        'origin': image.GetOrigin(),
                        'direction': image.GetDirection(),
                    'file_count': len(image_files),
                        'modality': self._get_image_modality(image_files[0])
                    }
                    
                self.logger.info(f"成功加载图像序列, 尺寸={image.GetSize()}, 原点={image.GetOrigin()}")
                except Exception as e:
                self.logger.error(f"加载图像序列时出错: {e}")
                return False, f"加载图像序列时出错: {e}", data_dict
            
            # 如果有RTSS，加载结构集
            rtss_file = data_dict['rtss_file']
            if rtss_file:
                self.progress_updated.emit(80, "加载RTSS结构集...")
                try:
                    rtss_data = pydicom.dcmread(rtss_file)
                    data_dict['rtss'] = rtss_data
                    self.logger.info(f"成功加载RTSS，包含 {self._count_rtss_contours(rtss_data)} 个轮廓")
                except Exception as e:
                    self.logger.warning(f"加载RTSS时出错: {e}")
                    # 继续处理，因为可以只有图像没有结构集
            
            # 更新加载状态
                data_dict['loaded'] = True
                self.progress_updated.emit(100, f"成功加载{'固定' if is_fixed else '移动'}图像")
                
                # 发送图像加载完成信号
                data_to_emit = data_dict.copy()
                data_to_emit['is_fixed'] = is_fixed  # 添加is_fixed标志
                self.image_loaded.emit(data_to_emit)
                
            return True, f"成功加载{'固定' if is_fixed else '移动'}图像", data_dict
                
        except Exception as e:
            msg = f"加载目录 {directory} 时出错: {e}"
            self.logger.error(msg, exc_info=True)
            return False, msg, {}
    
    def _get_image_modality(self, dicom_file: str) -> str:
        """获取DICOM图像的模态类型"""
        try:
            dcm = pydicom.dcmread(dicom_file, force=True, stop_before_pixels=True)
            return dcm.Modality if hasattr(dcm, 'Modality') else "未知"
        except:
            return "未知"
            
    def _count_rtss_contours(self, rtss_data) -> int:
        """统计RTSS中的轮廓数量"""
        try:
            if hasattr(rtss_data, 'ROIContourSequence'):
                return len(rtss_data.ROIContourSequence)
            return 0
        except:
            return 0
            
    def get_data_summary(self, is_fixed: bool = True) -> Dict:
        """
        获取加载数据的摘要信息，用于GUI显示
        
        Args:
            is_fixed: 是否获取固定图像的摘要
            
        Returns:
            Dict: 数据摘要
        """
        data_dict = self.fixed_data if is_fixed else self.moving_data
        
        if not data_dict['loaded']:
            return {
                'loaded': False,
                'message': '未加载数据'
            }
            
        image_info = data_dict['image_info']
        
        summary = {
            'loaded': True,
            'modality': image_info.get('modality', '未知'),
            'size': image_info.get('size', (0, 0, 0)),
            'spacing': image_info.get('spacing', (0, 0, 0)),
            'slice_count': image_info.get('size', (0, 0, 0))[2],
            'file_count': image_info.get('file_count', 0),
            'has_rtss': data_dict['rtss'] is not None,
            'rtss_contour_count': self._count_rtss_contours(data_dict['rtss']) if data_dict['rtss'] else 0
        }
        
        return summary
        
    def set_transform_parameters(self, tx=0.0, ty=0.0, tz=0.0, rx=0.0, ry=0.0, rz=0.0):
        """
        设置变换参数
        
        Args:
            tx: x方向平移（mm）
            ty: y方向平移（mm）
            tz: z方向平移（mm）
            rx: x轴旋转（度）
            ry: y轴旋转（度）
            rz: z轴旋转（度）
        """
        self.transform_params = {
            'tx': float(tx),
            'ty': float(ty),
            'tz': float(tz),
            'rx': float(rx),
            'ry': float(ry),
            'rz': float(rz),
        }
        self.logger.info(f"设置变换参数: 平移=({tx}, {ty}, {tz})mm, 旋转=({rx}, {ry}, {rz})度")
    
    def perform_rigid_registration(self):
        """
        执行刚体配准，使用预设的参数将移动图像配准到固定图像
        
        Returns:
            Tuple[bool, str]: (成功标志, 消息)
        """
        try:
            # 检查是否有输出目录
            if not hasattr(self, 'output_dir') or not self.output_dir:
                return False, "未设置输出目录，请先选择输出目录"
                
            # 获取输出选项
            output_image = True
            output_rtss = True
            
            # 执行刚体变换
            success, message = self.perform_rigid_transform(
                self.output_dir,
                output_image=output_image,
                output_rtss=output_rtss
            )
            
            return success, message
            
        except Exception as e:
            error_msg = f"执行刚体配准时出错: {e}"
            self.logger.error(error_msg, exc_info=True)
            return False, error_msg
        
    def print_debug_info(self, fixed_image, moving_image, tx, ty, tz):
        """将关键的空间信息直接打印到控制台，避免警告消息干扰"""
        print("\n\n========== 图像空间信息详细比较 ==========")
        fixed_origin = fixed_image.GetOrigin()
        moving_origin = moving_image.GetOrigin()
        
        print("--- 基本空间信息 ---")
        print(f"Fixed图像: origin=({fixed_origin[0]:.2f}, {fixed_origin[1]:.2f}, {fixed_origin[2]:.2f}), spacing={fixed_image.GetSpacing()}, size={fixed_image.GetSize()}")
        print(f"Moving图像: origin=({moving_origin[0]:.2f}, {moving_origin[1]:.2f}, {moving_origin[2]:.2f}), spacing={moving_image.GetSpacing()}, size={moving_image.GetSize()}")
        
        print("\n--- 空间差异 ---")
        origin_diff = (
            fixed_origin[0] - moving_origin[0],
            fixed_origin[1] - moving_origin[1],
            fixed_origin[2] - moving_origin[2]
        )
        print(f"原点差异(Fixed - Moving): ({origin_diff[0]:.2f}, {origin_diff[1]:.2f}, {origin_diff[2]:.2f}) mm")
        
        print("\n--- 计算的平移参数 ---")
        print(f"平移参数: tx={tx:.2f}, ty={ty:.2f}, tz={tz:.2f} mm")
        
        expected_new_origin = (
            moving_origin[0] + tx, 
            moving_origin[1] + ty, 
            moving_origin[2] + tz
        )
        
        print("\n--- 预期结果 ---")
        print(f"平移后预期新origin: ({expected_new_origin[0]:.2f}, {expected_new_origin[1]:.2f}, {expected_new_origin[2]:.2f})")
        
        expected_diff = (
            expected_new_origin[0] - fixed_origin[0],
            expected_new_origin[1] - fixed_origin[1],
            expected_new_origin[2] - fixed_origin[2]
        )
        print(f"与Fixed的origin预期差异: ({expected_diff[0]:.2f}, {expected_diff[1]:.2f}, {expected_diff[2]:.2f}) mm")
        
        # 检查Z轴差异是否特别大
        if abs(origin_diff[2]) > 500 or abs(tz) > 500:
            print("\n!!! 警告：Z轴差异非常大，可能需要特别关注 !!!")
            print(f"Z轴原点差异: {origin_diff[2]:.2f} mm")
            print(f"Z轴平移参数: {tz:.2f} mm")
            print("确保GUI的Z轴平移范围足够大（±2000mm）以容纳这个差异")
            print("注意: 如果界面上显示的Z轴平移参数不是{tz:.2f}mm，请手动设置为这个值！")
            
        print("=======================================\n")
        
    def perform_rigid_transform(self, output_dir: str, output_image=True, output_rtss=True) -> Tuple[bool, str]:
        """
        执行刚体变换，并将结果保存到指定目录
        
        Args:
            output_dir: 输出目录路径
            output_image: 是否输出变换后的图像
            output_rtss: 是否输出变换后的RTSS
            
        Returns:
            Tuple[bool, str]: (成功标志, 消息)
        """
        try:
            # 检查是否已加载数据
            if not (self.fixed_data['loaded'] and self.moving_data['loaded']):
                return False, "请先加载固定和移动图像数据"
                
            # 检查输出目录
            if not output_dir:
                return False, "请指定输出目录"
                
            # 确保输出目录存在
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)
                
            # 记录开始执行
            self.logger.info(f"开始执行刚体变换，参数: TX={self.transform_params['tx']}, TY={self.transform_params['ty']}, TZ={self.transform_params['tz']}, RX={self.transform_params['rx']}, RY={self.transform_params['ry']}, RZ={self.transform_params['rz']}")
            self.progress_updated.emit(5, "正在准备刚体变换...")
            
            # 提取参数
            tx = self.transform_params['tx']
            ty = self.transform_params['ty']
            tz = self.transform_params['tz']
            rx = self.transform_params['rx']
            ry = self.transform_params['ry']
            rz = self.transform_params['rz']
            
            # 准备用于存储结果的变量
            transformed_image = None
            transformed_rtss = None
            
            # 执行图像变换
            if output_image and self.moving_data['images']:
                self.progress_updated.emit(10, "正在执行图像刚体变换...")
                
                # 获取移动图像和固定图像
                moving_image = self.moving_data['images'][0]
                fixed_image = self.fixed_data['images'][0]
                
                # 使用控制台打印DEBUG信息，避免被警告覆盖
                self.print_debug_info(fixed_image, moving_image, tx, ty, tz)
                
                # 创建一个新的图像，复制moving_image的像素数据
                # 注意：SimpleITK不允许直接修改图像的Origin，需要创建一个新的图像
                moving_origin = moving_image.GetOrigin()
                moving_spacing = moving_image.GetSpacing()
                moving_direction = moving_image.GetDirection()
                
                # 计算调整后的origin（应用平移量）
                adjusted_origin = (
                    moving_origin[0] + tx,
                    moving_origin[1] + ty,
                    moving_origin[2] + tz
                )
                
                print(f"\n===== 调整Origin =====")
                print(f"原始Origin: {moving_origin}")
                print(f"平移量: ({tx}, {ty}, {tz})mm")
                print(f"调整后Origin: {adjusted_origin}")
                print(f"Fixed Origin: {fixed_image.GetOrigin()}")
                print(f"调整后与Fixed的Origin差异: {np.array(adjusted_origin) - np.array(fixed_image.GetOrigin())}")
                
                # 创建一个新的图像，复制moving_image但使用调整后的origin
                # 因为不能直接修改SimpleITK图像的Origin，所以创建一个新的
                adjusted_moving_image = sitk.Image(moving_image)
                adjusted_moving_image.SetOrigin(adjusted_origin)
                
                # 使用恒等变换和fixed_image作为参考进行重采样
                self.progress_updated.emit(30, "重采样到固定图像空间...")
                print("===== 开始重采样 =====")
                resampler = sitk.ResampleImageFilter()
                resampler.SetReferenceImage(fixed_image)  # 使用fixed_image的尺寸和间距
                resampler.SetInterpolator(sitk.sitkLinear)
                resampler.SetDefaultPixelValue(0)
                
                # 使用恒等变换，因为我们已经调整了origin
                identity_transform = sitk.Transform(3, sitk.sitkIdentity)
                resampler.SetTransform(identity_transform)
                
                transformed_image = resampler.Execute(adjusted_moving_image)
                
                # 打印重采样后信息
                print("===== 重采样完成 =====")
                print(f"重采样后图像: origin={transformed_image.GetOrigin()}, spacing={transformed_image.GetSpacing()}, size={transformed_image.GetSize()}")
                print(f"与Fixed对比: origin差异={np.array(transformed_image.GetOrigin()) - np.array(fixed_image.GetOrigin())}\n\n")
                
                # 保存变换后的图像
                self.progress_updated.emit(40, "正在保存变换后的图像...")
                
                # 保存DICOM格式的图像
                save_success, output_path = self._save_image_as_dicom(
                    transformed_image, 
                    output_dir, 
                    "transformed_image",
                    self.moving_data['image_files'][0]
                )
                
                if not save_success:
                    self.logger.warning(f"保存图像失败: {output_path}")
                else:
                    self.logger.info(f"已保存变换后的图像到: {output_path}")
            
            # 执行RTSS变换
            if output_rtss and self.moving_data['rtss'] is not None:
                self.progress_updated.emit(60, "正在执行RTSS刚体变换...")
                
                # 获取移动RTSS
                moving_rtss = self.moving_data['rtss']
                
                # 变换RTSS
                transformed_rtss = self._transform_rtss(moving_rtss, tx, ty, tz, rx, ry, rz)
                
                # 保存变换后的RTSS
                self.progress_updated.emit(80, "正在保存变换后的RTSS...")
                
                # 保存DICOM格式的RTSS
                rtss_success, rtss_path = self._save_rtss_as_dicom(
                    transformed_rtss, 
                    output_dir, 
                    "transformed_rtss"
                )
                
                if not rtss_success:
                    self.logger.warning(f"保存RTSS失败: {rtss_path}")
                else:
                    self.logger.info(f"已保存变换后的RTSS到: {rtss_path}")
            
            # 记录成功完成
            self.progress_updated.emit(100, "刚体变换完成!")
            return True, f"成功完成刚体变换，结果已保存到 {output_dir}"
            
        except Exception as e:
            error_msg = f"执行刚体变换时出错: {e}"
            self.logger.error(error_msg, exc_info=True)
            self.progress_updated.emit(0, f"错误: {error_msg}")
            return False, error_msg
    
    def _create_rigid_transform(self, tx, ty, tz, rx, ry, rz):
        """
        创建只做平移的3D变换（不做旋转）
        Args:
            tx, ty, tz: 平移参数（毫米）
            rx, ry, rz: 保留参数，不使用
        Returns:
            sitk.Transform: SimpleITK平移变换对象
        """
        transform = sitk.TranslationTransform(3)
        transform.SetOffset((float(tx), float(ty), float(tz)))
        return transform
    
    def _apply_transform_to_image(self, image: sitk.Image, transform: sitk.Transform) -> sitk.Image:
        """
        将变换应用到图像
        
        Args:
            image: 输入图像
            transform: 变换对象
            
        Returns:
            sitk.Image: 变换后的图像
        """
        # 设置插值器
        interpolator = sitk.sitkLinear
        
        # 设置默认像素值
        default_pixel_value = 0
        
        # 获取图像信息
        size = image.GetSize()
        spacing = image.GetSpacing()
        origin = image.GetOrigin()
        direction = image.GetDirection()
        
        # 应用变换
        transformed_image = sitk.Resample(
            image, 
            size, 
            transform, 
            interpolator, 
            origin, 
            spacing, 
            direction, 
            default_pixel_value
        )
        
        return transformed_image
    
    def _transform_rtss(self, rtss_data, tx, ty, tz, rx, ry, rz) -> pydicom.Dataset:
        """
        应用平移变换到RTSS结构集（不做旋转）
        Args:
            rtss_data: RTSS DICOM数据
            tx, ty, tz: 平移参数（毫米）
            rx, ry, rz: 保留参数，不使用
        Returns:
            pydicom.Dataset: 变换后的RTSS数据
        """
        transformed_rtss = rtss_data.copy()
        def transform_point(point):
            x, y, z = point
            return (x + tx, y + ty, z + tz)
        if not hasattr(transformed_rtss, 'ROIContourSequence'):
            return transformed_rtss
        for roi_contour in transformed_rtss.ROIContourSequence:
            if not hasattr(roi_contour, 'ContourSequence'):
                continue
            for contour in roi_contour.ContourSequence:
                if not hasattr(contour, 'ContourData') or contour.ContourData is None:
                    continue
                contour_data = contour.ContourData
                num_points = len(contour_data) // 3
                transformed_points = []
                for i in range(num_points):
                    x = float(contour_data[i*3])
                    y = float(contour_data[i*3 + 1])
                    z = float(contour_data[i*3 + 2])
                    x_new, y_new, z_new = transform_point((x, y, z))
                    transformed_points.extend([x_new, y_new, z_new])
                contour.ContourData = transformed_points
        return transformed_rtss
    
    def _save_image_as_dicom(self, image: sitk.Image, output_dir: str, base_name: str, reference_dicom_file: str) -> Tuple[bool, str]:
        """
        将图像保存为DICOM格式，确保所有切片被识别为同一个连续序列。
        保证所有图像切片属于同一序列，能被DICOM查看器作为一个序列加载。
        """
        try:
            image_output_dir = os.path.join(output_dir, base_name)
            if not os.path.exists(image_output_dir):
                os.makedirs(image_output_dir)
                
            image_array = sitk.GetArrayFromImage(image)
            size = image.GetSize()
            spacing = image.GetSpacing()
            origin = image.GetOrigin()
            direction = image.GetDirection()
            num_slices = image_array.shape[0]

            # 读取第一个参考DICOM，提取全局信息
            ref_dcm = pydicom.dcmread(reference_dicom_file, force=True)
            
            # 记录原始模态信息
            original_modality = ref_dcm.get('Modality', 'CT')
            self.logger.info(f"原始图像模态: {original_modality}")
            print(f"原始图像模态: {original_modality}")

            # 要保留的全局关键标签列表
            # 确保包含所有序列相关标签
            global_tags = [
                'PatientName', 'PatientID', 'PatientBirthDate', 'PatientSex',
                'StudyInstanceUID', 'StudyDate', 'StudyTime', 'StudyID',
                'AccessionNumber', 'ReferringPhysicianName', 
                'StationName', 'StudyDescription', 'InstitutionName'
            ]
            
            # 生成一个新的Series UID 和 Frame of Reference UID，所有切片共用
            study_uid = getattr(ref_dcm, 'StudyInstanceUID', pydicom.uid.generate_uid())
            new_series_uid = pydicom.uid.generate_uid()
            new_frame_of_reference_uid = pydicom.uid.generate_uid()
            series_number = getattr(ref_dcm, 'SeriesNumber', 1000)
            series_description = f"Transformed_{getattr(ref_dcm, 'SeriesDescription', base_name)}"
            
            # 确定Modality和SOPClassUID
            modality = original_modality
            if modality == 'PT' or 'PET' in str(getattr(ref_dcm, 'SeriesDescription', '')).upper():
                sop_class_uid = '1.2.840.10008.5.1.4.1.1.128'  # PET Image Storage
                modality = 'PT'  # 确保使用标准模态代码
            elif modality == 'CT':
                sop_class_uid = '1.2.840.10008.5.1.4.1.1.2'  # CT Image Storage
            elif modality == 'MR':
                sop_class_uid = '1.2.840.10008.5.1.4.1.1.4'  # MR Image Storage    
            else:
                sop_class_uid = '1.2.840.10008.5.1.4.1.1.2'  # 默认为CT Image Storage
                
            self.logger.info(f"使用模态: {modality}, SOPClassUID: {sop_class_uid}")
            print(f"使用模态: {modality}, SOPClassUID: {sop_class_uid}")
                
            # 以升序命名文件，确保DICOM浏览器能正确排序
            # 使用统一的命名前缀，许多PACS系统依赖这种命名约定识别序列
            file_prefix = "IM"  # 标准DICOM命名前缀
            
            # 预先计算所有切片的位置，以便正确排序
            slice_positions = []
            for i in range(num_slices):
                slice_pos = self.compute_image_position(origin, direction, i, spacing)[2]
                slice_positions.append((i, slice_pos))
            
            # 按Z位置排序，确保切片按解剖位置排序
            # 许多DICOM查看器依赖 ImagePositionPatient 的Z值递增或递减来确定顺序
            slice_positions.sort(key=lambda x: x[1])
            is_ascending = slice_positions[0][1] < slice_positions[-1][1]
            
            # 设置实例编号顺序，确保DICOM查看器能正确显示序列
            if is_ascending:
                instance_numbers = list(range(1, num_slices + 1))
            else:
                instance_numbers = list(range(num_slices, 0, -1))
            
            self.logger.info(f"保存DICOM序列，切片数: {num_slices}，顺序方向: {'升序' if is_ascending else '降序'}")
            
            # 保存每个切片的路径，用于创建DICOMDIR
            all_slice_paths = []
            
            # 保存每个切片
            for idx, (original_idx, z_pos) in enumerate(slice_positions):
                # 创建新的DICOM对象
                dcm = pydicom.Dataset()
                
                # 复制全局标签
                for tag in global_tags:
                    if hasattr(ref_dcm, tag):
                        setattr(dcm, tag, getattr(ref_dcm, tag))
                
                # 设置序列相关信息 - 所有切片必须共享这些值
                dcm.StudyInstanceUID = study_uid  # 确保所有切片共享相同的StudyInstanceUID
                dcm.SeriesInstanceUID = new_series_uid
                dcm.SeriesDescription = series_description
                dcm.SeriesNumber = series_number
                dcm.SeriesDate = getattr(ref_dcm, 'SeriesDate', getattr(ref_dcm, 'StudyDate', ''))
                dcm.SeriesTime = getattr(ref_dcm, 'SeriesTime', getattr(ref_dcm, 'StudyTime', ''))
                
                # 设置模态信息
                dcm.Modality = modality
                
                # 设置SOPClassUID和MediaStorageSOPClassUID
                dcm.SOPClassUID = sop_class_uid
                
                # 设置file_meta信息
                dcm.file_meta = pydicom.Dataset()
                dcm.file_meta.MediaStorageSOPClassUID = sop_class_uid
                dcm.SOPInstanceUID = pydicom.uid.generate_uid()
                dcm.file_meta.MediaStorageSOPInstanceUID = dcm.SOPInstanceUID
                dcm.file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRLittleEndian
                dcm.file_meta.ImplementationClassUID = pydicom.uid.PYDICOM_IMPLEMENTATION_UID
                
                # 设置FrameOfReferenceUID - 所有切片必须共享此值
                dcm.FrameOfReferenceUID = new_frame_of_reference_uid
                
                # 设置图像类型
                dcm.ImageType = ["DERIVED", "SECONDARY"]
                
                # 设置图像空间信息
                dcm.Rows = size[1]
                dcm.Columns = size[0]
                dcm.PixelSpacing = [spacing[1], spacing[0]]  # 注意XY顺序
                dcm.SliceThickness = spacing[2]
                dcm.SpacingBetweenSlices = spacing[2]
                
                # 计算当前切片的ImagePositionPatient
                image_position = self.compute_image_position(origin, direction, original_idx, spacing)
                dcm.ImagePositionPatient = [float(v) for v in image_position]
                
                # 设置图像方向
                image_orientation = [
                    direction[0], direction[3], direction[6],  # 第一列
                    direction[1], direction[4], direction[7]   # 第二列
                ]
                dcm.ImageOrientationPatient = [float(v) for v in image_orientation]
                
                # 设置切片位置 - 这对序列排序至关重要
                dcm.SliceLocation = float(z_pos)
                
                # 设置实例编号 - 按Z轴位置顺序递增或递减
                dcm.InstanceNumber = instance_numbers[idx]
                
                # 设置切片数据
                slice_data = image_array[original_idx, :, :]
                
                # 根据需要调整数据类型
                pixels_min = np.min(slice_data)
                pixels_max = np.max(slice_data)
                
                # 设置窗宽窗位
                if hasattr(ref_dcm, 'WindowCenter') and hasattr(ref_dcm, 'WindowWidth'):
                    dcm.WindowCenter = ref_dcm.WindowCenter
                    dcm.WindowWidth = ref_dcm.WindowWidth
                else:
                    dcm.WindowCenter = (pixels_max + pixels_min) // 2
                    dcm.WindowWidth = max(1, pixels_max - pixels_min)
                
                # 如果图像数据范围较小，可以使用16位整数
                if pixels_min >= -32768 and pixels_max <= 32767:
                    # 使用16位有符号整数
                    slice_data = slice_data.astype(np.int16)
                    dcm.BitsAllocated = 16
                    dcm.BitsStored = 16
                    dcm.HighBit = 15
                    dcm.PixelRepresentation = 1  # 有符号整数
                else:
                    # 使用缩放以适应16位范围
                    if pixels_min != pixels_max:
                        rescale_slope = (pixels_max - pixels_min) / 65534.0
                        rescale_intercept = float(pixels_min)
                        # 使用缩放来适应16位范围
                        rescaled_data = (slice_data - rescale_intercept) / rescale_slope
                        # 四舍五入并限制在合理范围内
                        slice_data = np.clip(np.round(rescaled_data), 0, 65535).astype(np.uint16)
                        dcm.RescaleSlope = rescale_slope
                        dcm.RescaleIntercept = rescale_intercept
                    else:
                        # 如果所有像素值相同
                        slice_data = np.zeros_like(slice_data, dtype=np.uint16)
                        dcm.RescaleSlope = 1.0
                        dcm.RescaleIntercept = float(pixels_min)
                    
                    dcm.BitsAllocated = 16
                    dcm.BitsStored = 16
                    dcm.HighBit = 15
                    dcm.PixelRepresentation = 0  # 无符号整数
                
                # 设置像素数据
                dcm.SamplesPerPixel = 1
                dcm.PhotometricInterpretation = "MONOCHROME2"
                dcm.PixelData = slice_data.tobytes()
                
                # 使用标准的DICOM文件命名约定，确保切片能正确排序
                output_file = os.path.join(image_output_dir, f"{file_prefix}{slice_idx+1:04d}.dcm")
                dcm.save_as(output_file)
                all_slice_paths.append(output_file)
            
            # 尝试创建DICOMDIR索引文件，帮助某些DICOM查看器识别序列
            try:
                from pydicom.fileset import FileSet
                from pydicom.uid import ExplicitVRLittleEndian
                
                fs = FileSet()
                for i in range(num_slices):
                    file_path = os.path.join(image_output_dir, f"{file_prefix}{i+1:04d}.dcm")
                    fs.add(file_path)
                fs.write(os.path.join(image_output_dir, "DICOMDIR"))
                self.logger.info("已创建DICOMDIR索引文件，帮助DICOM查看器识别序列")
                print("已创建DICOMDIR索引文件，帮助DICOM查看器识别序列")
            except Exception as e:
                self.logger.warning(f"创建DICOMDIR文件失败(不影响使用): {e}")
            
            self.logger.info(f"成功将图像保存为DICOM序列，共 {num_slices} 个切片，保存到 {image_output_dir}")
            print(f"成功将图像保存为DICOM序列，共 {num_slices} 个切片，保存到 {image_output_dir}")
            print(f"所有切片共享同一SeriesInstanceUID: {new_series_uid}")
            return True, image_output_dir
            
        except Exception as e:
            error_msg = f"保存DICOM图像时出错: {e}"
            self.logger.error(error_msg, exc_info=True)
            return False, error_msg
    
    def _save_rtss_as_dicom(self, rtss_data, output_dir: str, base_name: str) -> Tuple[bool, str]:
        """
        将RTSS保存为DICOM文件
        
        Args:
            rtss_data: RTSS DICOM数据
            output_dir: 输出目录
            base_name: 基础文件名
            
        Returns:
            Tuple[bool, str]: (成功标志, 输出路径或错误消息)
        """
        try:
            # 确保输出目录存在
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)
                
            # 创建输出文件路径
            output_file = os.path.join(output_dir, f"{base_name}.dcm")
            
            # 保存RTSS文件
            rtss_data.save_as(output_file, enforce_file_format=False)
            
            self.logger.info(f"已成功保存RTSS文件到: {output_file}")
            return True, output_file
            
        except Exception as e:
            error_msg = f"保存RTSS文件时出错: {e}"
            self.logger.error(error_msg, exc_info=True)
            return False, error_msg
        
    def calculate_centroid_from_rtss(self, rtss_data) -> Union[Tuple[float, float, float], None]:
        """
        计算RTSS中所有轮廓的质心
        
        Args:
            rtss_data: RTSS DICOM数据
            
        Returns:
            Tuple[float, float, float]: 质心坐标 (x, y, z) 或 None (如果计算失败)
        """
        try:
            if not rtss_data or not hasattr(rtss_data, 'ROIContourSequence'):
                self.logger.warning("RTSS数据不存在或没有轮廓序列")
                return None
                
            # 所有轮廓点的列表
            all_points = []
            
            # 遍历所有ROI轮廓
            for roi_contour in rtss_data.ROIContourSequence:
                if not hasattr(roi_contour, 'ContourSequence'):
                    continue
                    
                # 遍历每个轮廓的每个切片
                for contour in roi_contour.ContourSequence:
                    if not hasattr(contour, 'ContourData') or contour.ContourData is None:
                        continue
                        
                    # 获取轮廓点（每3个数值为一个点的x,y,z坐标）
                    contour_data = contour.ContourData
                    num_points = len(contour_data) // 3
                    
                    for i in range(num_points):
                        x = float(contour_data[i*3])
                        y = float(contour_data[i*3 + 1])
                        z = float(contour_data[i*3 + 2])
                        all_points.append((x, y, z))
            
            if not all_points:
                self.logger.warning("未找到有效的轮廓点")
                return None
                
            # 计算质心
            centroid_x = sum(p[0] for p in all_points) / len(all_points)
            centroid_y = sum(p[1] for p in all_points) / len(all_points)
            centroid_z = sum(p[2] for p in all_points) / len(all_points)
            
            self.logger.info(f"计算得到质心坐标: ({centroid_x}, {centroid_y}, {centroid_z})")
            return (centroid_x, centroid_y, centroid_z)
            
        except Exception as e:
            self.logger.error(f"计算质心时出错: {e}", exc_info=True)
            return None
            
    def calculate_transform_from_centroids(self) -> Tuple[bool, str, Dict]:
        """
        根据固定和移动RTSS的质心差异，计算刚体变换参数
        
        Returns:
            Tuple[bool, str, Dict]: (成功标志, 消息, 变换参数字典)
        """
        try:
            # 检查是否已加载数据
            if not (self.fixed_data['loaded'] and self.moving_data['loaded']):
                return False, "请先加载固定和移动图像数据", {}
                
            # 检查是否有RTSS
            if not (self.fixed_data['rtss'] and self.moving_data['rtss']):
                return False, "固定和移动图像数据必须都包含RTSS", {}
                
            # 计算固定图像的RTSS质心
            fixed_centroid = self.calculate_centroid_from_rtss(self.fixed_data['rtss'])
            if fixed_centroid is None:
                return False, "无法计算固定图像RTSS的质心", {}
                
            # 计算移动图像的RTSS质心
            moving_centroid = self.calculate_centroid_from_rtss(self.moving_data['rtss'])
            if moving_centroid is None:
                return False, "无法计算移动图像RTSS的质心", {}
                
            # 获取固定和移动图像的原点
            fixed_image = self.fixed_data['images'][0]
            moving_image = self.moving_data['images'][0]
            fixed_origin = fixed_image.GetOrigin()
            moving_origin = moving_image.GetOrigin()
            
            # 计算轮廓质心差异
            centroid_diff_x = fixed_centroid[0] - moving_centroid[0]
            centroid_diff_y = fixed_centroid[1] - moving_centroid[1]
            centroid_diff_z = fixed_centroid[2] - moving_centroid[2]
            
            # 计算图像原点差异
            origin_diff_x = fixed_origin[0] - moving_origin[0]
            origin_diff_y = fixed_origin[1] - moving_origin[1]
            origin_diff_z = fixed_origin[2] - moving_origin[2]
            
            # 计算总平移距离，考虑质心差异和原点差异
            # 这些平移值将用于移动moving图像，使其与fixed图像对齐
            tx = centroid_diff_x + origin_diff_x
            ty = centroid_diff_y + origin_diff_y
            tz = centroid_diff_z + origin_diff_z
            
            # 准备变换参数
            transform_params = {
                'tx': tx, 'ty': ty, 'tz': tz,
                'rx': 0.0, 'ry': 0.0, 'rz': 0.0  # 默认不旋转
            }
            
            # 输出详细的调试信息
            print("\n======== 详细计算刚体变换参数 ========")
            print(f"固定图像原点: ({fixed_origin[0]:.2f}, {fixed_origin[1]:.2f}, {fixed_origin[2]:.2f})")
            print(f"移动图像原点: ({moving_origin[0]:.2f}, {moving_origin[1]:.2f}, {moving_origin[2]:.2f})")
            print(f"原点差异: X={origin_diff_x:.2f}mm, Y={origin_diff_y:.2f}mm, Z={origin_diff_z:.2f}mm")
            
            print(f"固定图像质心: ({fixed_centroid[0]:.2f}, {fixed_centroid[1]:.2f}, {fixed_centroid[2]:.2f})")
            print(f"移动图像质心: ({moving_centroid[0]:.2f}, {moving_centroid[1]:.2f}, {moving_centroid[2]:.2f})")
            print(f"质心差异: X={centroid_diff_x:.2f}mm, Y={centroid_diff_y:.2f}mm, Z={centroid_diff_z:.2f}mm")
            
            # 特别关注Z轴的大偏移
            print(f"\n特别关注Z轴:")
            print(f"Z轴原点差异: {origin_diff_z:.2f}mm (二者可能在不同的坐标系统)")
            print(f"Z轴质心差异: {centroid_diff_z:.2f}mm (反映轮廓在不同扫描中的相对位置)")
            print(f"Z轴总平移量: {tz:.2f}mm (二者叠加，确保考虑两个坐标系的差异)")
            
            # 输出详细计算过程
            print(f"\n平移参数计算过程:")
            print(f"X平移 = 质心X差异 + 原点X差异 = {centroid_diff_x:.2f} + {origin_diff_x:.2f} = {tx:.2f}mm")
            print(f"Y平移 = 质心Y差异 + 原点Y差异 = {centroid_diff_y:.2f} + {origin_diff_y:.2f} = {ty:.2f}mm")
            print(f"Z平移 = 质心Z差异 + 原点Z差异 = {centroid_diff_z:.2f} + {origin_diff_z:.2f} = {tz:.2f}mm")
            
            # 如果Z轴偏移很大，特别提醒
            if abs(tz) > 500:
                print("\n!!! 重要提示 !!!")
                print(f"Z轴平移量 {tz:.2f}mm 非常大，请确保:")
                print("1. GUI中Z轴平移滑块已设置为±2000mm范围")
                print("2. 变换后查看结果验证对齐是否正确")
                print("3. 如果界面上显示的Z轴平移参数不是上面计算的值，请手动设置！")
            
            # 目前我们只计算平移，不计算旋转
            rx, ry, rz = 0.0, 0.0, 0.0
            
            # 更新变换参数
            self.set_transform_parameters(tx, ty, tz, rx, ry, rz)
            
            # 记录并返回结果
            message = f"已根据质心差异计算变换参数: 平移=({tx:.2f}, {ty:.2f}, {tz:.2f})mm"
            if abs(tz) > 500:
                message += f" - 注意Z轴偏移很大({tz:.2f}mm)!"
                
            self.logger.info(f"根据质心差异计算得到变换参数: 平移=({tx:.2f}, {ty:.2f}, {tz:.2f})mm")
            return True, message, transform_params
            
        except Exception as e:
            error_msg = f"计算变换参数时出错: {e}"
            self.logger.error(error_msg, exc_info=True)
            return False, error_msg, {}

    def compute_image_position(self, origin, direction, slice_number, spacing):
        """
        计算DICOM切片的ImagePositionPatient值
        
        Args:
            origin: 图像原点坐标
            direction: 图像方向余弦矩阵
            slice_number: 切片索引
            spacing: 图像间距
            
        Returns:
            List[float]: 切片的ImagePositionPatient值
        """
        # 将方向矩阵转换为3x3数组
        direction_mat = np.array(direction).reshape(3, 3)
        
        # 计算Z方向的单位向量
        z_unit = np.array([direction_mat[0, 2], direction_mat[1, 2], direction_mat[2, 2]])
        
        # 计算当前切片的偏移量
        offset = slice_number * spacing[2] * z_unit
        
        # 计算最终位置
        position = np.array(origin) + offset
        
        return position.tolist()